/*   SoundManager 2: Javascript Sound for the Web   --------------------------------------------   http://www.schillmania.com/projects/soundmanager2/   Copyright (c) 2007, Scott Schiller. All rights reserved.   Code licensed under the BSD License:   http://www.schillmania.com/projects/soundmanager2/license.txt   V2.0b.20070415   Compiling AS to Flash 8 SWF using MTASC (free compiler - http://www.mtasc.org/):   mtasc -swf flv.swf -main -header 16:16:30 FLVPlayer.as -version 8   cd /projects/bolaji.net/v6/www/02/music   /Applications/mtasc1.12/mtasc -cp "/Applications/Macromedia Flash 8/First Run/Classes" -swf musicplayer.swf Music.as -version 8   ActionScript Sound class reference (Macromedia):   http://livedocs.macromedia.com/flash/8/main/wwhelp/wwhimpl/common/html/wwhelp.htm?context=LiveDocs_Parts&file=00002668.html*/import mx.remoting.Service;import mx.remoting.PendingCall;import mx.rpc.ResultEvent;import mx.rpc.FaultEvent;import mx.rpc.RelayResponder;import mx.utils.Delegate;import mx.remoting.debug.NetDebug;import mx.events.EventDispatcher;import flash.external.ExternalInterface; // wooimport mx.controls.Button;import mx.controls.CustomButton;import mx.transitions.Tween;import mx.transitions.easing.*;class MusicPlayer extends MovieClip {// Constants:	public static var CLASS_REF		:Function	= MusicPlayer;	public static var LINKAGE_ID	:String		= "MusicPlayer";	public static var SymbolLinked	:Boolean	= Object.registerClass(LINKAGE_ID, CLASS_REF);	private var addEventListener	:Function;	private var removeEventListener	:Function;	private var drawRect	private var dispatchEvent		:Function;	private var arrDataObjects		:Array;	private var root				:Object;	private var delegate			:FlashRemoteDelegate;	private var conn				:NetConnection;	private var stream				:NetStream;	private var active				:Number;	private var progressInterval	:Number;	private var seekInterval		:Number;	private var timeInterval		:Number;	private var soundObj			:Sound;	private var debug				:Boolean = false;// Initialization:	private function MusicPlayer() {		EventDispatcher.initialize(this);		this.delegate = new FlashRemoteDelegate();		//this.debug = this.root.debug = true;		ExternalInterface.call("console.log", "debug["+this.root.debug+"]");		this.root = _root;		this.initData();		this.initInterface();		this.addEventListener("ready", Delegate.create(this, onReady));		this.addEventListener("pause", Delegate.create(this, onPause));		this.addEventListener("play", Delegate.create(this, onPlay));		this.addEventListener("next", Delegate.create(this, onNext));		this.addEventListener("prev", Delegate.create(this, onPrevious));		this.addEventListener("metadata", Delegate.create(this, onMetadata));		this.addEventListener("status", Delegate.create(this, onStatus));		this.addEventListener("progress", Delegate.create(this, onProgress));		this.addEventListener("seek", Delegate.create(this, onSeek));		this.addEventListener("time", Delegate.create(this, onTime));		this.addEventListener("drag", Delegate.create(this, onDrag));		this.addEventListener("action", Delegate.create(this, onActionHandler));	}	private function onStatus(evt:Object, delegate:Function):Void {		log( "onStatus evt["+evt+"] target["+evt.target+"] source["+evt.source+"]");		//log("onStatus sound["+ns.s.sID+"] aid["+ns.s.aid+"] sid["+ns.s.sid+"] loaded");		var sound = arrDataObjects[this.active];		for (var prop in evt)		{			//log("onStatus \t"+prop+":\t"+evt[prop]);		}		// once we are connected to the server create the nsPlay NetStream object		if (evt.code == "NetConnection.Connect.Success")		{			dispatchEvent({type:"play", target:this});		}		if(evt.code == "NetStream.Play.Stop")		{			log("fire onPlayStop");			clearInterval(this.progressInterval);			clearInterval(this.timeInterval);			clearInterval(this.seekInterval);			if(sound.next != null && typeof sound.next != 'undefined')			{				this.root.mcText.label.text = "Loading...";				var next = this.arrDataObjects[sound.next.split('|')[1]];				this.active = next.sid;				this.dispatchEvent({type:"play", target:this});			}		}		else if(evt.code == "NetStream.Play.Start")		{			log("fire onPlayStart");		}		else if(evt.code == "NetStream.Play.Reset")		{			log("fire onPlayReset");		}		else if(evt.code == "NetStream.Pause.Notify")		{			log("fire onPauseNotify");			this.root.mcControlBar.btnPause._alpha = 0;			this.root.mcControlBar.btnPlay._alpha = 100;			this.root.mcText.label.text = "Paused...";			clearInterval(this.seekInterval);			clearInterval(this.timeInterval);		}		else if(evt.code == "NetStream.Unpause.Notify")		{			log("fire onUnPauseNotify");			this.root.mcControlBar.btnPause._alpha = 100;			this.root.mcControlBar.btnPlay._alpha = 0;			this.root.mcText.label.text = "";			this.timeInterval = setInterval(Delegate.create(this, onTime), 500);			this.seekInterval = setInterval(Delegate.create(this, onSeek), 500);		}		else if(evt.code == "NetStream.Buffer.Full")		{			log("fire onBufferFull");		}		else if(evt.code == "NetStream.Buffer.Empty")		{			log("fire onBufferEmpty");		}		else if(evt.code == "NetStream.Buffer.Flush")		{			log("fire onBufferFlush");		}		else if(evt.code == "NetStream.Seek.Notify")		{			log("fire onNotifySeek");			this.seekInterval = setInterval(Delegate.create(this, onSeek), 300);		}	}	private function onMetadata(evt:Object, delegate:Function):Void {		log( "evt["+evt+"] target["+evt.target+"] source["+evt.source+"]");		for (var prop in evt) 		{			log("onMetadata \t"+prop+":\t"+evt[prop]);		}			var sound = arrDataObjects[this.active];		sound.duration = evt.duration;		arrDataObjects[this.active] = sound;		this.root.mcText.label.text = "";		this.root.mcInfo.title.text = sound.metadata.split(",")[0].toUpperCase();		this.root.mcInfo.subtitle.text = this.capitalize(sound.metadata.split(",")[1], true);		var artistnameid = sound.metadata.split(",")[2];		ExternalInterface.call("nowplaying", sound.aid, sound.sid, artistnameid, this.root.mcInfo.title.text, this.root.mcInfo.subtitle.text);		this.root.mcTime.dur.text = '00:00 / ' + this.formatTime(evt.duration);		this.root.mcControlBar.btnPlay._alpha = 0;		this.root.mcControlBar.btnPause._alpha = 100;		log("onMetadata sound["+sound.sID+"] aid["+sound.aid+"] sid["+sound.sid+"] loaded");		this.dispatchEvent({type:"progress", target:this});		this.dispatchEvent({type:"time", target:this});		this.dispatchEvent({type:"seek", target:this});		this.progressInterval = setInterval(Delegate.create(this, onProgress), 500);		this.timeInterval = setInterval(Delegate.create(this, onTime), 500);		this.seekInterval = setInterval(Delegate.create(this, onSeek), 500);	}	private function onReady(evt:Object, delegate:Function):Void {		log( "onReady evt["+evt+"] target["+evt.target+"] source["+evt.source+"]");		var songid = this.root.sid;		var artistid = this.root.aid;		if(arrDataObjects.length != 0) {			if(typeof songid != 'undefined') {				this.active = songid;				var sound = arrDataObjects[this.active];				log("onReady url["+(sound.url.split("!")[0])+"] track["+(sound.url.split("!")[1])+"]");				//TODO: FIX STATEFUL CONNECTIONS PROBLEM				//MAKE SURE NET CONNECTION IS REUSED FOR EACH PLAYBACK				if(this.conn == null)				{					this.conn = new NetConnection();					log("onReady connect["+sound.url.split("!")[0]+"]");					this.conn.connect(sound.url.split("!")[0]);					this.conn.onStatus = Delegate.create(this, onStatus);				}				else				{					this.dispatchEvent({type:"play", target:this});				}			}		}	}	private function onPause(evt:Object, delegate:Function):Void {		log( "onPause evt["+evt+"] target["+evt.target+"] source["+evt.source+"]");		this.stream.pause();	}	private function onPlay(evt:Object, delegate:Function):Void {		log( "onPlay evt["+evt+"] target["+evt.target+"] source["+evt.source+"] active["+this.active+"]");		if(typeof this.active != 'undefined') {			this.stream = new NetStream(this.conn);			//ns.play("mp3:"+nc.s.url.split("!")[1]);			stream.play(this.arrDataObjects[this.active].url.split("!")[1]);				log("called ns.play on " + this.arrDataObjects[this.active].url.split("!")[1]);			stream.onStatus = Delegate.create(this, onStatus);			stream.onMetaData = Delegate.create(this, onMetadata);			this.delegate.call("NumOfPlay", "music.song:" + this.arrDataObjects[this.active].sid, this, "onRemotingResult", "onRemotingError");		}	}	private function onTime(evt:Object, delegate:Function):Void {		var sound = this.arrDataObjects[this.active];		this.root.mcTime.dur.text = this.formatTime(Math.min(sound.duration, Math.ceil(this.stream.time))) + ' / ' + this.formatTime(sound.duration);	}	private function onSeek(evt:Object, delegate:Function):Void {		var sound = this.arrDataObjects[this.active];		//var perc = (this.root.mcControlBar.mcScrubber._x) / 290;		this.root.mcControlBar.mcScrubber._x = ((this.stream.time / sound.duration) * 290) + 6;		this.root.mcControlBar.mcSeek._width = ((this.stream.time / sound.duration) * 290);		//this.root.mcControlBar.mcScrubber._x = (((sound.duration * perc) / sound.duration) * 290) + 6;		//this.root.mcControlBar.mcSeek._width = (((sound.duration * perc) / sound.duration) * 290);		log("onSeek mcSeek[" +this.root.mcControlBar.mcSeek._width+ "] mcScrubber[" + this.root.mcControlBar.mcScrubber._x + "]");	}	private function onProgress(evt:Object, delegate:Function):Void {		var sound = this.arrDataObjects[this.active];		  var bL = this.stream.bytesLoaded;		  var bT = this.stream.bytesTotal;		  var nD = sound.duration||0; // can sometimes be null with short MP3s? Wack.		  var nP = this.stream.time;		//log('onProgress bL['+bL+'] bT['+bT+'] nD['+nD+'] nP['+Math.round(nP)+']');		if(bL && bT && bL != bT)		{			log("onProgress loading... ");		}		if(typeof nP != 'undefined' && nP != nD)		{			//log("onProgress playing... ");			//this.root.mcControlBar.mcScrubber._x = ((nP / nD) * 290) + 6;			//this.root.mcControlBar.mcSeek._width = ((nP / nD) * 290);			//log(" scrubber[" + (this.root.mcControlBar.mcScrubber._x) + "] seek["+ this.root.mcControlBar.mcSeek._width +"] perc[" + ((nP / nD) * 100) + "]");		}	}	private function onActionHandler(evt:Object, delegate:Function):Void {		log( "onActionHandler evt["+evt+"] target["+evt.target+"] source["+evt.source+"]");		var sound = this.arrDataObjects[this.active];		switch(evt.source) {			case this.root.mcControlBar.btnVol :				this.soundObj.setVolume((typeof sound.vol == 'undefined') ? 0 : sound.vol != 100 ? 100 : 0);				sound.vol = this.soundObj.getVolume();				if(sound.vol != 100) this.root.mcControlBar.btnVol._alpha = 50;				else this.root.mcControlBar.btnVol._alpha = 100;				break;		}	}	private function onPrevious(evt:Object, delegate:Function):Void {		log( "evt["+evt+"] target["+evt.target+"] source["+evt.source+"]");	}	private function onNext(evt:Object, delegate:Function):Void {		log( "evt["+evt+"] target["+evt.target+"] source["+evt.source+"]");	}	public function onRemotingHandler(re:ResultEvent) {		arrDataObjects = new Array();		//Implement custom callback code		log(" *** handleSongList Result: ccID[" + re.result.ccID + "]");		log(" *** handleSongList Result: items[" + re.result.items +"]");		//ccID = re.result.ccID;		var items = re.result.items;		for(var i=0; i < items.length; i++) {			var item = items[i].split('|');			var s = new Object();			s.didJustBeforeFinish = false;			s.sID = re.result.ccID;			s.aid = item[0];			s.sid = item[1];			s.url = item[2];			s.metadata = item[3];			s.paused = false;			s.loaded = false;			s.justBeforeFinishOffset = 0;			s.lastValues = {			  bytes: 0,			  position: 0,			  nLoops: 1			};			s.prev = (i-1) >= 0 ? items[i-1] : null;			s.next = (i+1) <= items.length ? items[i+1] : null;			this.arrDataObjects[item[1]] = s;			//_load(item[1],true,false);			//sounds.push(item[1]);		}		this.dispatchEvent({type:"ready", target:this});	}	public function onRemotingResult(re:ResultEvent) {		log( '*** handleRemotingResult Result: ' + re.result);	}	public function onRemotingError(fault:FaultEvent) {		log('*** handleRemotingError message: ' + fault.fault.faultstring);	}	private function initData():Void {		log( "cc[" + this.root.cc + "] aid["+this.root.aid+"] sid["+this.root.sid+"]");		//TODO: GET SONGLIST		var result = this.delegate.call("music." + this.root.cc, this.root.aid, this, "onRemotingHandler", "onRemotingError");	}	private function initInterface():Void {		//loading...		this.root.mcText = MovieClip(this.attachMovie("Text", "mcText", this.getNextHighestDepth()));		var mcText = this.root.mcText;		mcText._x = 245;		mcText._y = 110;		mcText.label.align = "center";		mcText.label.size = 9;		//control bar		this.root.mcControlBar = MovieClip(this.root.attachMovie("ControlBar", "mcControlBar", this.getNextHighestDepth()));		var mcControlBar = this.root.mcControlBar;		mcControlBar._x = 31;		mcControlBar._y = 126;		mcControlBar.btnPause._alpha = 0;		//buffer		var mcBuffer = mcControlBar.createEmptyMovieClip("mcBuffer", mcControlBar.getNextHighestDepth());		mcControlBar.mcBuffer.beginFill(0x999999, 50);		mcControlBar.mcBuffer.lineTo(1, 0);		mcControlBar.mcBuffer.lineTo(1, 5);		mcControlBar.mcBuffer.lineTo(0, 5);		mcControlBar.mcBuffer.lineTo(0, 0);		mcControlBar.endFill();		mcControlBar.mcBuffer._x = 5;		mcControlBar.mcBuffer._y = 4;		mcControlBar.mcBuffer._width = 290;		//seek		var mcSeek = mcControlBar.createEmptyMovieClip("mcSeek", mcControlBar.getNextHighestDepth());		mcControlBar.mcSeek.beginFill(0xcccccc, 100);		mcControlBar.mcSeek.lineTo(1, 0);		mcControlBar.mcSeek.lineTo(1, 5);		mcControlBar.mcSeek.lineTo(0, 5);		mcControlBar.mcSeek.lineTo(0, 0);		mcControlBar.endFill();		mcControlBar.mcSeek._x = mcControlBar.mcBuffer._x;		mcControlBar.mcSeek._y = mcControlBar.mcBuffer._y;		//scrubber		mcControlBar.attachMovie("Scrubber", "mcScrubber", mcControlBar.getNextHighestDepth());		mcControlBar.mcScrubber._x = 7;		mcControlBar.mcScrubber._y = 7;		mcControlBar.mcScrubber.onPress = function() { 			var mcMusicPlayer = this._parent._parent.mcMusicPlayer;			mcMusicPlayer.dispatchEvent({type:"drag", target:mcMusicPlayer, source:"start"});		}		mcControlBar.mcScrubber.onRelease = 		mcControlBar.mcScrubber.onReleaseOutside = function() { 			var mcMusicPlayer = this._parent._parent.mcMusicPlayer;			mcMusicPlayer.dispatchEvent({type:"drag", target:mcMusicPlayer, source:"stop"});		}		mcControlBar.btnPause._alpha = 0;		mcControlBar.btnPause.onRelease = 		mcControlBar.btnPlay.onRelease = function() { 			var mcMusicPlayer = this._parent._parent.mcMusicPlayer;			mcMusicPlayer.dispatchEvent({type:"pause", target:mcMusicPlayer, source:"play"});		}		mcControlBar.btnVol.onRelease = function() { 			var mcMusicPlayer = this._parent._parent.mcMusicPlayer;			mcMusicPlayer.dispatchEvent({type:"action", target:mcMusicPlayer, source:this});		}		//image		this.root.mcImage = MovieClip(this.attachMovie("Image", "mcImage", this.getNextHighestDepth()));		var mcImage = this.root.mcImage;		mcImage._x = 46;		mcImage._y = 35;		//info		this.root.mcInfo = MovieClip(this.attachMovie("Info", "mcInfo", this.getNextHighestDepth()));		var mcInfo = this.root.mcInfo;		mcInfo._x = 10;		mcInfo._y = 70;		//time		this.root.mcTime = MovieClip(this.attachMovie("Time", "mcTime", this.getNextHighestDepth()));		var mcTime = this.root.mcTime;		mcTime._x = 360;		mcTime._y = 8;		this.soundObj = new Sound();		this.soundObj.setVolume(100);	}	private function onDrag(evt:Object, delegate:Function):Void {		log( "evt["+evt+"] target["+evt.target+"] source["+evt.source+"]");		clearInterval(this.seekInterval);		if(evt.source == "start") {			this.root.mcControlBar.mcScrubber.startDrag(false, 7, this.root.mcControlBar.mcScrubber._y, 293, this.root.mcControlBar.mcScrubber._y);		}		else if(evt.source == "stop") {			this.root.mcControlBar.mcScrubber.stopDrag();			var perc = (this.root.mcControlBar.mcScrubber._x - 7) / 290;			this.seekPercent(perc * 100);		}	}	private function seekPercent(perc:Number):Void{		seek(this.arrDataObjects[this.active].duration * (perc / 100));	}	public function seek(time:Number):Void{		log("seek time[" + time+ "]");		this.stream.seek(Math.floor(time));	}	private function formatTime(time:Number):String {		var min = Math.floor(time/60);		var sec = Math.floor(time%60);		if(sec < 10){		 sec = "0" + sec;		}		if(min < 10) {		 min = "0" + min;		}		var pos = min + ":" + sec;		return pos;	}	private function formatTime2(time:Number):String{	  var elapsedTime = time;	  //Minutes	  var elapsedM = Math.floor(elapsedTime/60000);	  var remaining = elapsedTime - (elapsedM * 60000);	  //add a leading zero if it's a single digit number	  if(elapsedM < 10){elapsedM = "0"+elapsedM;}	  //Seconds	  var elapsedS = Math.floor(remaining/1000);	  remaining -= (elapsedM*1000);	  //add leading zero	  if(elapsedS<10){elapsedS = "0"+elapsedS;}	  //Hundreths	  var elapsedFractions = Math.floor(remaining/10);	  if(elapsedFractions < 10){elapsedFractions = "0" +elapsedFractions;}	  //display result nicely	  return elapsedM + ":" + elapsedS;// + ":" + elapsedFractions;  }  // optional flag, 1 capitalise only first word, else every word is capitalised  function capitalize(sent, flag) {	  var terug = "";	  var str = sent;	  var tmp ="";	  var allWords = str.split(" ");// into array delimiter is space	  	for (var i=0; i < allWords.length; i++) {			tmp = allWords[i]; // for clarity sake only			allWords[i] = tmp.substr(0,1).toUpperCase() + tmp.substr(1, tmp.length-1);		}	  for (var i=0; i < allWords.length - 1;i++){		  terug += allWords[i] + " ";	  }	  return terug + allWords[allWords.length-1];	  // otherwise a space will be added to the final word as well.  }  function log(logStr:String) {	  if(this.debug != 'undefined' && this.debug) {		  ExternalInterface.call("console.log", logStr);	  }  }// Public Methods:	public function toString() : String {		return "MusicPlayer";	}}