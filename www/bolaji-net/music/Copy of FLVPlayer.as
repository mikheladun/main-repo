/*   SoundManager 2: Javascript Sound for the Web   --------------------------------------------   http://www.schillmania.com/projects/soundmanager2/   Copyright (c) 2007, Scott Schiller. All rights reserved.   Code licensed under the BSD License:   http://www.schillmania.com/projects/soundmanager2/license.txt   V2.0b.20070415   Compiling AS to Flash 8 SWF using MTASC (free compiler - http://www.mtasc.org/):   mtasc -swf flv.swf -main -header 16:16:30 FLVPlayer.as -version 8   cd /projects/bolaji.net/v6/www/02/music   /Applications/mtasc1.12/mtasc -cp "/Applications/Macromedia Flash 8/First Run/Classes" -swf flv.swf FLVPlayer.as -version 8   ActionScript Sound class reference (Macromedia):   http://livedocs.macromedia.com/flash/8/main/wwhelp/wwhimpl/common/html/wwhelp.htm?context=LiveDocs_Parts&file=00002668.html*/import mx.remoting.Service;import mx.remoting.PendingCall;import mx.rpc.ResultEvent;import mx.rpc.FaultEvent;import mx.rpc.RelayResponder;import mx.utils.Delegate;import mx.remoting.debug.NetDebug;import mx.video.FLVPlayback;import mx.events.EventDispatcher;import flash.external.ExternalInterface; // wooclass FLVPlayer extends MovieClip {		//#include "FlashRemoteDelegate.as"// Constants:	public static var CLASS_REF		:Function	= FLVPlayer;	public static var LINKAGE_ID	:String		= "FLVPlayer";	public static var SymbolLinked	:Boolean	= Object.registerClass(LINKAGE_ID, CLASS_REF);	public static var baseJSController	:String = "soundManager";	public static var baseJSObject		:String = baseJSController + ".sounds";// Public Properties:	public var addEventListener			:Function;	public var removeEventListener		:Function;	public var autoPlay					:Boolean = false;	public var bufferTime				:Number = 0.1;	public var playheadTime				:Number = 0;	public var playheadUpdateInterval	:Number		= 250;	public var progressInterval			:Number = 250;	public var state					:String = "";	public var stateResponsive			:Boolean = false;	public var buffering				:Boolean = false;// Private Properties:	private var dispatchEvent		:Function;	private var _arrFLVPlayback		:Array;	private var _activeFlvPlayback	:FLVPlayback;	private var _position			:Number = 0;	private var _volume				:Number = 100;	private var _arrCuePoints		:Array;	private var delegate					:FlashRemoteDelegate;	private var _activeDataObject 			:Object;	private var _arrDataObjects				:Array;	private var mcVideo						:FLVPlayback;	private var mcMedia						:MediaDisplay;	private var completeEvent			:Boolean = false;	private var forceCompleteInterval	:Number;// UI Elements:// ** AUTO-UI ELEMENTS **	private var mcBackground:MovieClip;// ** END AUTO-UI ELEMENTS **	// Initialization:	private function FLVPlayer() {		EventDispatcher.initialize(this);		_arrFLVPlayback		= new Array();		_arrCuePoints		= new Array();		_arrDataObjects		= new Array();		ExternalInterface.addCallback('_externalInterfaceTest', this, externalInterfaceTest);		ExternalInterface.addCallback('_unload', this, unload);		ExternalInterface.addCallback('_stop', this, stop);		ExternalInterface.addCallback('_start', this, start);		ExternalInterface.addCallback('_pause', this, pause);		ExternalInterface.addCallback('_setPosition', this, function(nPerc:Number) {this.seekPercent(nPerc);});		ExternalInterface.addCallback('_setVolume', this, function (nVol:Number) {this.volume = nVol;});		ExternalInterface.addCallback('_createSound', this, createSound);		ExternalInterface.addCallback('_playPrev', this, playPrev);		ExternalInterface.addCallback('_playNext', this, playNext);		delegate = new FlashRemoteDelegate();	}	private function onLoad():Void { 		configUI(); 	}// Public Methods:	public function toString() : String {		return "FLVPlayer";	}		public function get width():Number{		return _width;	}		public function set width(intSet:Number):Void{		_width = intSet;	}		public function get height():Number{		return _height;	}		public function set height(intSet:Number):Void{		_height = intSet;	}	public function get playing():Boolean{		return _activeFlvPlayback.playing;	}		public function get volume():Number{		return _volume;	}		public function set volume(intSet:Number):Void{		_volume = intSet;		_activeFlvPlayback.volume = _volume;	}		public function setVolume(intSet:Number):Void {		this.volume = intSet;	}	public function pause():Void{		if(_activeFlvPlayback.state == "paused")			_activeFlvPlayback.play();		else		_activeFlvPlayback.pause();	}		public function play():Void{		_activeFlvPlayback.play();	}		public function stop():Void{		_activeFlvPlayback.stop();		seek(0);	}		public function seek(time:Number):Void{		var blnSet		:Boolean	= false;		var intLength	:Number		= 0;		var blnPlaying	:Boolean	= _activeFlvPlayback.playing;				buffering	= true;		dispatchEvent({type:"seeking", target:this});				for(var i:Number=0; i<_arrFLVPlayback.length; i++){			if(!blnSet){				var flvCurrent	:FLVPlayback	= _arrFLVPlayback[i];								if(time < (intLength + flvCurrent.totalTime)){					if(flvCurrent != _activeFlvPlayback){						_activeFlvPlayback.stop();												_activeFlvPlayback = flvCurrent;													_activeFlvPlayback.seek(time - intLength);												if(blnPlaying){								_activeFlvPlayback.play();						}					}else{						flvCurrent.seek(time - intLength);					}										blnSet = true;				}else{					intLength += flvCurrent.totalTime;				}			}		}	}		public function addCuePoint(intNew:Number):Void{		var blnAdd	:Boolean	= true;				for(var i:Number=0; i<_arrCuePoints.length; i++){			if(_arrCuePoints[i] == intNew){				blnAdd = false;			}		}				if(blnAdd){			_arrCuePoints.push(intNew);			_arrCuePoints.sort(Array.NUMERIC);		}	}		public function removeCuePoint(intRemove:Number):Void{		var blnAdd	:Boolean	= true;				for(var i:Number=0; i<_arrCuePoints.length; i++){			if(_arrCuePoints[i] == intRemove){				_arrCuePoints.splice(i,1);				_arrCuePoints.sort(Array.NUMERIC);				break;			}		}	}		public function seekToNextCuePoint():Void{		for(var i:Number=0; i<_arrCuePoints.length; i++){			if((_arrCuePoints[i] < playheadTime)){				if(_arrCuePoints[i+1] != null){					if(_arrCuePoints[i+1] > playheadTime){						seek(_arrCuePoints[i+1]);					}				}			}		}	}		public function seekToLastCuePoint():Void{		for(var i:Number=0; i<_arrCuePoints.length; i++){			if((_arrCuePoints[i] < playheadTime)){				if(_arrCuePoints[i+1] != null){					if(_arrCuePoints[i+1] > playheadTime){						if(((_arrCuePoints[i] + 2) > playheadTime) && (_arrCuePoints[i-1] != null)){							seek(_arrCuePoints[i-1]);						}else{								seek(_arrCuePoints[i]);						}					}				}			}		}	}	// Semi-Private Methods:// Private Methods:	private function configUI():Void {	}		private function seekPercent(time:Number):Void{		seek((_activeFlvPlayback.totalTime/100)*time);	}	private function onMetadata(event:Object, delegate:Function):Void{		ExternalInterface.call("soundManager['_writeDebug']","(Flash): duration[" + event.info.duration + "] totalTime[" + _activeFlvPlayback.totalTime + "]");		dispatchEvent({type:"metadata", target:this});		event.target.removeEventListener("metadata", delegate);	}	private function onReady(event:Object, delegate:Function):Void{		FLVPlayback(event.target).volume = _volume;		stateResponsive = true;		dispatchEvent({type:"ready", target:this});		ExternalInterface.call("soundManager['_writeDebug']","(Flash): Total play time for this video is: " + _activeFlvPlayback.totalTime);		ExternalInterface.call("soundManager['_writeDebug']","(Flash): onReady sound[" + _activeDataObject.sID + "] aid[" + _activeDataObject.aid + "] vid[" + _activeDataObject.sid + "] loaded");		ExternalInterface.call(baseJSObject+"['" + _activeDataObject.sID + "']._onload", 1, _activeDataObject.sID, _activeDataObject.aid, _activeDataObject.sid, _activeDataObject.metadata);		event.target.removeEventListener("ready", delegate);	}	private function onPlayheadUpdate(event:Object, delegate:Function):Void{		//ExternalInterface.call("soundManager['_writeDebug']","(Flash): onPlayheadUpdate playheadTime[" + event.playheadTime + "] totalTime[" + event.totalTime + "]");		dispatchEvent({type:"playheadUpdate", target:this, playheadTime:playheadTime});		var bL = _activeFlvPlayback.bytesLoaded;		var bT = _activeFlvPlayback.bytesTotal;		var nD = _activeFlvPlayback.totalTime||0;		var nP = _activeFlvPlayback.playheadTime||0;		//ExternalInterface.call("soundManager['_writeDebug']","(Flash): onPlayheadUpdate  url[" + _activeDataObject.sID + "] bL[" + bL + "] bT[" + bT + "] nD[" + nD + "] nP[" + nP + "] totalTime[" + totalTime + "]");		//ExternalInterface.call("soundManager['_writeDebug']","(Flash): onPlayheadUpdate  nD[" + nD + "] nP[" + nP + "] " + Math.round(((nP / nD) * 100)) + "% complete" );		ExternalInterface.call(baseJSObject+"['" + _activeDataObject.sID + "']._whileplaying",bL,bT,nD,nP);		if((nP / nD) >= .99) {			clearInterval(forceCompleteInterval);			forceCompleteInterval = setInterval(this, "forceComplete", 5000);			ExternalInterface.call("soundManager['_writeDebug']","(Flash): forceComplete event set forceCompleteInterval[" + forceCompleteInterval + "]");		}	}	private function onProgress(event:Object, delegate:Function):Void{		ExternalInterface.call("soundManager['_writeDebug']","(Flash): onProgress bL[" + _activeFlvPlayback.bytesLoaded + "] bT[" + _activeFlvPlayback.bytesTotal + "] ");		dispatchEvent({type:"progress", target:this});	}	private function onStateChange(event:Object, delegate:Function):Void{		ExternalInterface.call("soundManager['_writeDebug']","(Flash): onStateChange() state[" + event.state + "] target[" + event.target + "] equals[" + (event.target == _activeFlvPlayback) + "]");		if(event.target == _activeFlvPlayback){			var objEvent	:Object = new Object();			objEvent.target			= this;			objEvent.type			= "stateChange";			objEvent.state			= event.state;			objEvent.playheadTime	= playheadTime;						dispatchEvent(objEvent);						switch(event.state){				case "buffering":					buffering	= true;					dispatchEvent({type:"buffering", target:this});				break;				case "playing":					buffering	= false;					dispatchEvent({type:"playing", target:this});				break;				case "stopped":					buffering	= false;					dispatchEvent({type:"stopped", target:this});				break;				case "paused":					buffering	= false;					dispatchEvent({type:"paused", target:this});				break;			}		}	}	private function onComplete(event:Object, delegate:Function):Void {		clearInterval(forceCompleteInterval);		ExternalInterface.call("soundManager['_writeDebug']","(Flash): onComplete() sound[" + _activeDataObject + "] sound[" + _activeDataObject.sID + "] aid[" + _activeDataObject.aid + "] vid[" + _activeDataObject.sid + "] complete");		ExternalInterface.call("soundManager.sounds['" + _activeDataObject.sID+ "']._onfinish");		this.playNext();		this.completeEvent = true;	}	public function forceComplete():Void {		clearInterval(forceCompleteInterval);		ExternalInterface.call("soundManager['_writeDebug']","(Flash): forceComplete clear interval completeEvent[" + completeEvent + "] forceCompleteInterval [" + forceCompleteInterval + "]");		if(!completeEvent) {			ExternalInterface.call("soundManager['_writeDebug']","(Flash): forceComplete() _activeDataObject[" + _activeDataObject + "] sound[" + _activeDataObject.sID + "] aid[" + _activeDataObject.aid + "] vid[" + _activeDataObject.sid + "] complete");			ExternalInterface.call("soundManager.sounds['" + _activeDataObject.sID+ "']._onfinish");			this.playNext();		}		this.completeEvent = true;	}	public function playNext():Void {		_activeFlvPlayback.stop();		clearInterval(forceCompleteInterval);		completeEvent = false;		if(_activeDataObject.next != null && typeof _activeDataObject.next != 'undefined')		{			var next = _arrDataObjects[_activeDataObject.next.split('|')[1]];			ExternalInterface.call("soundManager['_writeDebug']","(Flash): onComplete curr[" + _activeDataObject.sID + "] next[" + next.sID + "] next[" + next.sid + "] aid[" + _activeDataObject.aid +"] url[" + next.url + "]");			start(next.sid);		}	}	public function playPrev():Void {		_activeFlvPlayback.stop();		clearInterval(forceCompleteInterval);		completeEvent = false;		if(_activeDataObject.prev != null && typeof _activeDataObject.prev != 'undefined')		{			var prev = _arrDataObjects[_activeDataObject.prev.split('|')[1]];			ExternalInterface.call("soundManager['_writeDebug']","(Flash): onComplete curr[" + _activeDataObject.sID + "] next[" + prev.sID + "] next[" + prev.sid + "] aid[" + _activeDataObject.aid +"] url[" + prev.url + "]");			start(prev.sid);		}	}	function start (sID,nLoops,nMsecOffset):Void {		clearInterval(forceCompleteInterval);		ExternalInterface.call("soundManager['_writeDebug']","(Flash): start() sid[" + sID + '] url[' + _arrDataObjects[sID].url + ']');		//this.mcVideo = FLVPlayback(this.attachMovie("FLVPlayback", "mcVideo", this.getNextHighestDepth()));		this.mcDisplay = 		//this.attachMovie("FLVPlayback", "mcVideo", this.getNextHighestDepth());		//this.mcVideo.width = 402;		this.mcVideo.height = 302;		this.mcVideo.addEventListener("metadataReceived", Delegate.create(this, onMetadata));		this.mcVideo.addEventListener("ready", Delegate.create(this, onReady));		this.mcVideo.addEventListener("progress", Delegate.create(this, onProgress));		this.mcVideo.addEventListener("playheadUpdate", Delegate.create(this, onPlayheadUpdate));		this.mcVideo.addEventListener("stateChange", Delegate.create(this, onStateChange));		this.mcVideo.addEventListener("complete", Delegate.create(this, onComplete));		this.mcVideo.maintainAspectRatio = true;		this.mcVideo.autoPlay = false;		this.mcVideo.autoRewind = true;		this.mcVideo.bufferTime = bufferTime;		this.mcVideo.playheadUpdateInterval	= playheadUpdateInterval;		this.mcVideo.progressInterval			= progressInterval;		this.mcVideo.contentPath = _arrDataObjects[sID].url;		this.mcVideo.play();		_activeFlvPlayback = this.mcVideo;		_activeDataObject = _arrDataObjects[sID];		//function(eventObject:Object):Void {			//var tw = new mx.transitions.Tween(this, "_alpha", mx.transitions.easing.None.easeOut, 100, 0, 1, true);			//tw.onMotionFinished = function() { stiTilVideo.minVideo.contentPath="en anden video"; };			//}	  	delegate.call("NumOfPlay", "music.video:" + sID, this, "handleRemotingResult", "handleRemotingError");	}	public function createSound (sID,justBeforeFinishOffset):Void {		ExternalInterface.call("soundManager['_writeDebug']","(Flash): createSound CALLED : " + sID);		var s = sID.split(":");		ExternalInterface.call("soundManager['_writeDebug']","(Flash): createSound s[" + s + "]");		var aID;		if(s.length==2)		{			sID=s[0];			aID=s[1];			ExternalInterface.call("soundManager['_writeDebug']","(Flash): createSound sID[" + sID + "] aID[" + aID + "]");		}				//TODO: GET VIDEOLIST		 delegate.call(sID, aID, this, "handleSongList", "handleRemotingError");	}		public function handleSongList(re:ResultEvent):Void {		//Implement custom callback code		ExternalInterface.call("soundManager['_writeDebug']","(Flash): *** handleSongList Result: ccID[" + re.result.ccID + "]");		ExternalInterface.call("soundManager['_writeDebug']","(Flash): *** handleSongList Result: items[" + re.result.items +"]");		var items = re.result.items;		for(var i=0;i<items.length;i++) {			var item = items[i].split('|');			var s = new Object();			s.sID = re.result.ccID;			s.aid = item[0];			s.sid = item[1];			s.url = item[2];			ExternalInterface.call("soundManager['_writeDebug']","(Flash): *** handleSongList Result: url[" + s.url +"]");			s.metadata = item[3];			s.lastValues = {			  bytes: 0,			  position: 0,			  nLoops: 1			};			s.prev = (i-1) >= 0 ? items[i-1] : null;			s.next = (i+1) <= items.length ? items[i+1] : null;			_arrDataObjects[item[1]] = s;		}		ExternalInterface.call(baseJSController+"['initComplete']",null);	}		public function handleRemotingResult(re:ResultEvent):Void {		ExternalInterface.call("soundManager['_writeDebug']","(Flash): *** handleRemotingResult Result: " + re.result);	}		public function handleRemotingError(fault:FaultEvent):Void {		ExternalInterface.call("soundManager['_writeDebug']","(Flash): *** handleRemotingError message: " + fault.fault.faultstring);		NetDebug.trace({level:"None", message:"Error: " + fault.fault.faultstring });	}		public function externalInterfaceTest():Boolean {		ExternalInterface.call("soundManager['_writeDebug']","(Flash): _externalInterfaceTest()");		return true; // to verify that a call from JS to here, works. (eg. JS receives "true", thus OK.)	}		public function unload(sID:Number, sURL:String):Void {		// effectively "stop" loading by loading a tiny MP3		ExternalInterface.call("soundManager['_writeDebug']","(Flash): unload() ** NOT IMPLEMENTED **");		//_activeFlvPlayback = _arrFLVPlayback[sID];		//s.didJustBeforeFinish = false;	}}